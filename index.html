å¥½çš„ï¼Œæˆ‘å·²ç»ä¸ºæ‚¨ä¿®æ”¹äº†ä»£ç ã€‚æˆ‘æ·»åŠ äº† Eason Chan (é™ˆå¥•è¿…) çš„æ­Œæ›²ã€Šçƒ­å¸¦é›¨æ—ã€‹ä½œä¸ºèƒŒæ™¯éŸ³ä¹ã€‚

**å…³é”®æ”¹åŠ¨ç‚¹ï¼š**

1.  **éŸ³ä¹æ–‡ä»¶åµŒå…¥ï¼š** æˆ‘å‡è®¾æ‚¨æœ‰ä¸€ä¸ªåä¸º `tropical_rainforest.mp3` çš„éŸ³ä¹æ–‡ä»¶ä¸æ‚¨çš„ HTML æ–‡ä»¶ä½äºåŒä¸€ç›®å½•ä¸‹ã€‚å¦‚æœæ‚¨æ²¡æœ‰è¿™ä¸ªæ–‡ä»¶ï¼Œè¯·æ›¿æ¢ä¸ºæ‚¨è‡ªå·±çš„æ–‡ä»¶è·¯å¾„ã€‚
2.  **æ’­æ”¾æŒ‰é’®ï¼š** æ·»åŠ äº†ä¸€ä¸ªé€æ˜çš„ã€ä½äºå·¦ä¸Šè§’çš„æ’­æ”¾æŒ‰é’®ã€‚
3.  **ç”¨æˆ·äº¤äº’ï¼š** æµè§ˆå™¨é™åˆ¶è‡ªåŠ¨æ’­æ”¾ï¼Œæ‰€ä»¥éŸ³ä¹éœ€è¦ç”¨æˆ·ç‚¹å‡»æ’­æ”¾æŒ‰é’®åæ‰ä¼šå¼€å§‹æ’­æ”¾ã€‚
4.  **éŸ³ä¹æ§åˆ¶ï¼š** éŸ³ä¹ä¼šåœ¨è¿›å…¥â€œæ˜Ÿç³»å†…éƒ¨â€ï¼ˆ`insideStar = true`ï¼‰æ—¶éŸ³é‡å‡å°ï¼ˆå˜æŸ”å’Œï¼‰ï¼Œç¦»å¼€æ—¶æ¢å¤æ­£å¸¸éŸ³é‡ï¼Œä»¥å¢å¼ºæ²‰æµ¸æ„Ÿã€‚

è¯·ç¡®ä¿å°†æ‚¨çš„éŸ³ä¹æ–‡ä»¶å‘½åä¸º `tropical_rainforest.mp3` å¹¶æ”¾åœ¨ä¸æ­¤ HTML æ–‡ä»¶ç›¸åŒçš„æ–‡ä»¶å¤¹ä¸­ã€‚

```html
<!DOCTYPE html>
<html>
<head>
    <title>ç²’å­æ‰‹åŠ¿äº¤äº’ç³»ç»Ÿ - åŒå­æ˜Ÿä¾§è¾¹æç¤ºèåˆç‰ˆ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* ======================================= */
        /* 1. Three.js åŸºç¡€æ ·å¼ */
        /* ======================================= */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas { display: block; }
        
        #fullscreen-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 8px 12px;
            background-color: rgba(30, 30, 30, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            cursor: pointer;
            z-index: 1000;
            transition: background-color 0.3s;
        }
        #fullscreen-btn:hover {
            background-color: rgba(60, 60, 60, 0.9);
        }

        /* éšè—æ‘„åƒå¤´è§†é¢‘æµ */
        #video-container {
            position: absolute;
            opacity: 0; 
            pointer-events: none;
            z-index: -1;
        }

        .dg.main {
            z-index: 1001 !important;
            top: 50px !important;
            border-radius: 5px;
            right: 15px !important; 
        }
        
        /* éŸ³ä¹æ’­æ”¾æ§åˆ¶æŒ‰é’®æ ·å¼ */
        #music-control-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 8px 12px;
            background-color: rgba(255, 100, 100, 0.8);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            z-index: 1000;
            transition: background-color 0.3s, opacity 0.5s;
            font-weight: bold;
        }
        #music-control-btn:hover {
            background-color: rgba(255, 50, 50, 1);
        }

        /* ======================================= */
        /* 2. æ¸©é¦¨æç¤º CSS æ ·å¼ */
        /* ======================================= */
        
        /* æ¨¡æ‹Ÿæç¤ºçª—å£çš„æ ·å¼ */
        .tip-window {
            position: fixed; 
            width: 300px;
            height: 90px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            font-family: 'å¾®è½¯é›…é»‘', sans-serif;
            font-size: 16px;
            color: #333;
            opacity: 0; 
            transition: opacity 0.5s, transform 0.5s; 
            z-index: 500; /* ç¡®ä¿ä¸è¢« Three.js è¦†ç›– */
        }

        /* æœ€ç»ˆçª—å£çš„æ ·å¼ */
        #final-window {
            position: fixed;
            width: 400px;
            height: 120px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: lightpink;
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: none; 
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            box-shadow: 0 0 30px lightpink;
            opacity: 0;
            transition: opacity 1s;
            z-index: 2000; 
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="video-container">
        <video id="webcam-video" playsinline></video> 
    </div>
    
    <!-- éŸ³ä¹æ§åˆ¶æŒ‰é’® -->
    <button id="music-control-btn">â–¶ï¸ æ’­æ”¾èƒŒæ™¯éŸ³ä¹ (çƒ­å¸¦é›¨æ—)</button>
    
    <button id="fullscreen-btn">å…¨å±</button>

    <div id="final-window">
        æˆ‘æƒ³ä½ äº†
    </div>

    <audio id="background-music" loop preload="auto">
        <!-- ğŸš¨ è¯·å°† tropical_rainforest.mp3 æ”¾å…¥åŒçº§ç›®å½• -->
        <source src="tropical_rainforest.mp3" type="audio/mpeg">
        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script> 

    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/RGBShiftShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script>
        // =================================================================
        //                 å…¨å±€å˜é‡å’Œå‚æ•°è®¾ç½® (åŒå­æ˜Ÿéƒ¨åˆ†)
        // =================================================================
        let scene, camera, renderer, composer; 
        let star1, star2, trailParticles, backgroundParticles; 
        let imagePlanes = []; 
        let fireworks = []; 
        let lastFireworkTime = 0; 
        let lastMotionTime = 0; 
        let orbitTime = 0; 
        let cameraTargetZ = 10; 
        let insideStar = false; 
        let finalTipShown = false; // æ ‡è®°æœ€ç»ˆçª—å£æ˜¯å¦å·²æ˜¾ç¤º
        let musicPlaying = false; 

        const ORBIT_TILT_ANGLE = Math.PI * 0.11; 
        let lastStar1Position = new THREE.Vector3(); 
        const TRAIL_VELOCITY = 0.12; 

        const Params = {
            starColor1: 0x81C7E6, starColor2: 0xEFC4C4, particleSize: 0.031, targetSpread: 3.5, 
            starDensity: 14000, orbitRadius: 2.8, orbitSpeed: 0.012,
            trailColor: 0x90B5D6, trailDensity: 2000, trailSpread: 0.15, trailSize: 0.02, trailLength: 120,
            exposure: 1.2, bloomStrength: 1.7, bloomThreshold: 0.7, bloomRadius: 0.98,
            fireworkInterval: 1, fireworkDensity: 5200, fireworkSpread: 5, fireworkLifetime: 2, enableFireworks: true
        };

        const IMAGE_FILES = [
            'IMG_20251008_180842.jpg', 'light_shadow_border_1758868022928.jpg', 
            'mmexport1759924058791.jpg', 'mmexport1759924088470.jpg', 
            'mmexport1759924093473.jpg', 'mmexport1759924102487.jpg', 
            'mmexport1764822928436.jpg', 'mmexport1764822953695.jpg', 
            'mmexport1764822958536.jpg', 'mmexport1764822966406.jpg', 
            'mmexport1764822967696.jpg', 'mmexport1764822970360.jpg', 
            'mmexport1764822973131.jpg', 'mmexport1764822974719.jpg', 
            'mmexport1764822984508.jpg', 'mmexport1764823046062.jpg', 
            'mmexport1764823054048.jpg', 'mmexport1764823065525.jpg', 
            'mmexport1764823101912.jpg', 'mmexport1764823110358.jpg', 
            'mmexport1764823157249.jpg', 'mmexport1764823175328.jpg',
        ];
        
        const IMAGE_BASE_PATH = ''; 

        let particleScale = 1.0; 
        let targetScale = 1.0;   
        let particlesPosition = new THREE.Vector3(0, 0, 0); 
        let targetPosition = new THREE.Vector3(0, 0, 0);    
        const SMOOTHING_FACTOR = 0.15; 
        const WINDOW_SIZE = 5; 
        let scaleHistory = [];
        let positionXHistory = [];
        let positionYHistory = [];

        // =================================================================
        //                 æ¸©é¦¨æç¤ºå˜é‡å’Œå‡½æ•° 
        // =================================================================
        const W_TIPS = [
            'å¤šå–æ°´å“¦~', 'å°å¿ƒæˆ‘æä½ ', 'å“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå¯çˆ±','æˆ‘å®³æ€•','åƒé¥±äº†','åƒé¥±äº†','å¥½å®å®','æˆ‘å¯æ˜¯å¤§ç‹','å°çŒª',
            'åƒæ°´æœ', 'ä¿æŒå¥½å¿ƒæƒ…', 'å¥½å¥½çˆ±è‡ªå·±', 'æˆ‘æƒ³ä½ äº†','æœ‰å®åŠ›å“¦','ç­‰å¾…~','ç•¥ç•¥','å˜»å˜»',
            'æ¢¦æƒ³æˆçœŸ', 'æœŸå¾…ä¸‹ä¸€æ¬¡è§é¢', 'è¾›è‹¦äº†~', 'è®²å“©æ»´','é€—é€—ä½ ','çƒ§é¸­ç²‰~','å¥½å¹¸ç¦','æ•™å®˜å®˜',
            'æ„¿æ‰€æœ‰çƒ¦æ¼éƒ½æ¶ˆå¤±', 'ç­”åº”æˆ‘æ—©ç‚¹ç¡', 'æŠŠè¢«å­ç›–å¥½', 'å¤©å†·äº†ï¼Œå¤šç©¿è¡£æœ'
        ];
        
        const W_COLORS = [
            'lightpink', 'skyblue', 'lightgreen', 'lavender',
            'lightyellow', 'plum', 'coral', 'bisque', 'aquamarine',
            'mistyrose', 'honeydew', 'lavenderblush', 'oldlace'
        ];

        const W_CREATE_INTERVAL = 50; 
        const W_PROBABILITY = 0.5;    
        const W_CENTER_EXCLUSION = 400; 
        
        const w_finalWindowElement = document.getElementById('final-window');

        /**
         * åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„æç¤ºçª—å£å…ƒç´ 
         */
        function createTipWindow() {
            const W_WIDTH = 300;
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const centerMargin = (screenWidth - W_CENTER_EXCLUSION) / 2;
            
            const tip = W_TIPS[Math.floor(Math.random() * W_TIPS.length)];
            const bg = W_COLORS[Math.floor(Math.random() * W_COLORS.length)];

            let x;
            if (Math.random() < 0.5) {
                x = Math.random() * (centerMargin - W_WIDTH);
            } else {
                x = centerMargin + W_CENTER_EXCLUSION + Math.random() * (screenWidth - (centerMargin + W_CENTER_EXCLUSION) - W_WIDTH);
            }
            
            const y = Math.random() * (screenHeight - 90);

            const windowDiv = document.createElement('div');
            windowDiv.className = 'tip-window';
            windowDiv.textContent = tip;
            windowDiv.style.backgroundColor = bg;
            windowDiv.style.left = `${x}px`;
            windowDiv.style.top = `${y}px`;
            
            document.body.appendChild(windowDiv);
            
            setTimeout(() => {
                windowDiv.style.opacity = '1';
            }, 50);

            const closeDelay = Math.random() * 2000 + 1000; 

            setTimeout(() => {
                windowDiv.style.opacity = '0';
                windowDiv.style.transform = 'scale(0.8)'; 
                
                setTimeout(() => {
                    if (windowDiv.parentElement) {
                        windowDiv.parentElement.removeChild(windowDiv);
                    }
                }, 500); 
            }, closeDelay);

            if (Math.random() < 0.01 && !finalTipShown) {
                createFinalWindow();
            }
        }

        /**
         * åˆ›å»ºæœ€ç»ˆçš„â€œæˆ‘æƒ³ä½ äº†â€çª—å£
         */
        function createFinalWindow() {
            if (finalTipShown) return;
            finalTipShown = true; 
            w_finalWindowElement.style.display = 'flex'; 
            
            setTimeout(() => {
                w_finalWindowElement.style.opacity = '1';
            }, 50);
        }

        /**
         * å¾ªç¯åˆ›å»ºçª—å£çš„ä¸»å‡½æ•° (å·²æ·»åŠ  insideStar è”åŠ¨)
         */
        function createWindowsLoop() {
            if (insideStar) {
                setTimeout(createWindowsLoop, 500); 
                return;
            }

            if (Math.random() < W_PROBABILITY) {
                createTipWindow();
            }
            
            setTimeout(createWindowsLoop, W_CREATE_INTERVAL);
        }
        
        // =================================================================
        //                     æ ¸å¿ƒåŠŸèƒ½å‡½æ•°å®šä¹‰ (åŒå­æ˜Ÿéƒ¨åˆ†)
        // =================================================================
        
        const ParticleModels = {
            Sphere: (count, spread) => { 
                const pos = [];
                for (let i = 0; i < count; i++) {
                    const radius = Math.cbrt(Math.random()) * spread; 
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(Math.random() * 2 - 1);
                    pos.push(radius * Math.sin(phi) * Math.cos(theta));
                    pos.push(radius * Math.sin(phi) * Math.sin(theta));
                    pos.push(radius * Math.cos(phi));
                }
                return pos;
            },
            CometTrail: (count, spread) => { 
                const positions = [];
                const ages = []; 
                for (let i = 0; i < count; i++) {
                    positions.push((Math.random() - 0.5) * spread * 0.1); 
                    positions.push((Math.random() - 0.5) * spread * 0.1);
                    positions.push((Math.random() - 0.5) * spread * 0.1);
                    ages.push(Math.random() * Params.trailLength); 
                }
                return { positions, ages };
            },
            Firework: (count, spread) => { 
                const positions = [];
                for (let i = 0; i < count; i++) {
                    const radius = Math.random() * spread;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(Math.random() * 2 - 1);
                    positions.push(radius * Math.sin(phi) * Math.cos(theta));
                    positions.push(radius * Math.sin(phi) * Math.sin(theta));
                    positions.push(radius * Math.cos(phi));
                }
                return positions;
            }
        };

        function createBackgroundParticles() {
              const bgGeometry = new THREE.BufferGeometry();
            const bgPositions = [];
            const bgCount = 500;
            for (let i = 0; i < bgCount; i++) {
                bgPositions.push((Math.random() - 0.5) * 100); 
                bgPositions.push((Math.random() - 0.5) * 100);
                bgPositions.push((Math.random() - 0.5) * 100);
            }
            bgGeometry.setAttribute('position', new THREE.Float32BufferAttribute(bgPositions, 3));
            const bgMaterial = new THREE.PointsMaterial({
                color: 0x555555,
                size: 0.1,
                sizeAttenuation: true
            });
            backgroundParticles = new THREE.Points(bgGeometry, bgMaterial);
            scene.add(backgroundParticles);
        }

        function updateParticleSystem(targetObject, modelName, color, density, spread, size, isInitial = false) {
            let modelData;
            if (modelName === 'CometTrail') {
                modelData = ParticleModels[modelName](density, spread);
            } else {
                modelData = { positions: ParticleModels[modelName](density, spread) };
            }
            
            const newPositions = modelData.positions;
            const particleCount = newPositions.length / 3;
            
            const colors = new Float32Array(particleCount * 3);
            const baseColor = new THREE.Color(color);
            const centerColor = new THREE.Color(0xFFFFFF); 

            for (let i = 0; i < particleCount; i++) {
                if (modelName === 'Sphere') {
                    const x = newPositions[i * 3];
                    const y = newPositions[i * 3 + 1];
                    const z = newPositions[i * 3 + 2];
                    const distance = Math.sqrt(x*x + y*y + z*z);
                    const distanceRatio = distance / spread; 
                    
                    const finalColor = new THREE.Color();
                    finalColor.copy(baseColor).lerp(centerColor, 1 - distanceRatio); 

                    colors[i * 3 + 0] = finalColor.r;
                    colors[i * 3 + 1] = finalColor.g;
                    colors[i * 3 + 2] = finalColor.b;
                } else {
                    colors[i * 3 + 0] = baseColor.r;
                    colors[i * 3 + 1] = baseColor.g;
                    colors[i * 3 + 2] = baseColor.b;
                }
            }

            if (isInitial || targetObject === undefined || targetObject.geometry.attributes.position.count !== particleCount) {
                const particleGeometry = new THREE.BufferGeometry();
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(newPositions), 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                if (modelName === 'CometTrail') {
                    particleGeometry.setAttribute('age', new THREE.BufferAttribute(new Float32Array(modelData.ages), 1));
                    particleGeometry.setAttribute('startPosition', new THREE.BufferAttribute(new Float32Array(newPositions), 3));
                }
                
                const particleMaterial = new THREE.PointsMaterial({
                    size: size,
                    vertexColors: true, 
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false, 
                    sizeAttenuation: true
                });

                if (targetObject) scene.remove(targetObject);
                targetObject = new THREE.Points(particleGeometry, particleMaterial);
                
                if (modelName === 'CometTrail') {
                    targetObject.userData.ages = modelData.ages; 
                }
                
                scene.add(targetObject);
                return targetObject; 
            } else {
                targetObject.geometry.attributes.position.array.set(newPositions);
                targetObject.geometry.attributes.position.needsUpdate = true;
                targetObject.geometry.attributes.color.array.set(colors);
                targetObject.geometry.attributes.color.needsUpdate = true;

                if (modelName === 'CometTrail') {
                    targetObject.userData.ages = modelData.ages;
                    targetObject.geometry.attributes.age.array.set(modelData.ages);
                    targetObject.geometry.attributes.age.needsUpdate = true;
                }

                targetObject.material.color.set(new THREE.Color(color)); 
                targetObject.material.size = size;
                return targetObject;
            }
        }

        function loadAllImagesAndCreatePlanes(imagePaths) {
            const textureLoader = new THREE.TextureLoader();
            const geometry = new THREE.PlaneGeometry(1, 1); 
            const MAX_POSITION_RANGE = 8.0; 
            const MIN_SCALE = 0.5; 
            const MAX_SCALE = 1.0; 
            const BASE_IMAGE_WIDTH = 1.0; 

            imagePaths.forEach((filename) => {
                const path = IMAGE_BASE_PATH + filename;
                
                textureLoader.load(path, function(texture) {
                    
                    const aspectRatio = texture.image.width / texture.image.height;
                    const width = BASE_IMAGE_WIDTH;
                    const height = BASE_IMAGE_WIDTH / aspectRatio;
                    const randomScale = MIN_SCALE + Math.random() * (MAX_SCALE - MIN_SCALE);
                    
                    const material = new THREE.MeshBasicMaterial({
                        map: texture, 
                        transparent: true,
                        opacity: 0.0, 
                        blending: THREE.AdditiveBlending, 
                        side: THREE.DoubleSide
                    });
                    
                    const imagePlane = new THREE.Mesh(geometry, material);
                    imagePlane.scale.set(width * randomScale, height * randomScale, 1);

                    const randomX = (Math.random() - 0.5) * 2 * MAX_POSITION_RANGE;
                    const randomY = (Math.random() - 0.5) * 2 * MAX_POSITION_RANGE;
                    const randomZ = (Math.random() - 0.5) * 2 * MAX_POSITION_RANGE;
                    imagePlane.position.set(randomX, randomY, randomZ);
                    
                    scene.add(imagePlane);
                    imagePlanes.push(imagePlane);

                }, undefined, function(err) {
                    console.error(
                        'âŒ åŠ è½½å›¾ç‰‡å¤±è´¥ï¼Œè¯·æ£€æŸ¥ä»¥ä¸‹å‡ ç‚¹ï¼š', 
                        '\n1. è·¯å¾„æ˜¯å¦æ­£ç¡®: ', path, 
                        '\n2. æ£€æŸ¥å›¾ç‰‡æ–‡ä»¶æ˜¯å¦**ä½äºä¸ index.html åŒä¸€æ–‡ä»¶å¤¹**ã€‚',
                        '\n3. **é‡è¦ï¼šæ‚¨æ˜¯å¦åœ¨æœ¬åœ° Web Server ä¸Šè¿è¡Œï¼Ÿ** å°è¯•ä½¿ç”¨ VS Code Live Server æˆ–å…¶ä»–æœ¬åœ°æœåŠ¡å™¨å¯åŠ¨ HTML æ–‡ä»¶ã€‚',
                        '\nåŸå§‹é”™è¯¯:', err
                    );
                });
            });
        }
        
        function onResults(results) {
            let rawScaleInput = 1.0;
            let currentHandPosition = null;

            const detectedHands = results.multiHandLandmarks; 
            const handCount = detectedHands ? detectedHands.length : 0;
            const SCENE_SENSITIVITY = 8; 
            const limit = 3.5;
            
            if (handCount >= 2) {
                const hand1 = detectedHands[0];
                const hand2 = detectedHands[1];
                const wrist1 = hand1[0];
                const wrist2 = hand2[1]; 
                
                if (!wrist1 || !wrist2) return; 
                
                const handDistance = Math.sqrt(
                    Math.pow(wrist1.x - wrist2.x, 2) + Math.pow(wrist1.y - wrist2.y, 2)
                );
                const minDistance = 0.1;
                const maxDistance = 0.6;
                const normalizedDistance = Math.min(1.0, Math.max(0.0, (handDistance - minDistance) / (maxDistance - minDistance)));
                rawScaleInput = 0.5 + normalizedDistance * 0.5;
                const centerX = (wrist1.x + wrist2.x) / 2;
                const centerY = (wrist1.y + wrist2.y) / 2;
                
                currentHandPosition = new THREE.Vector3(
                    (0.5 - centerX) * SCENE_SENSITIVITY, 
                    (0.5 - centerY) * SCENE_SENSITIVITY, 0 
                );

            } else if (handCount === 1) {
                const handLandmarks = detectedHands[0];
                const thumbTip = handLandmarks[4];
                const pinkyTip = handLandmarks[20];
                
                if (!thumbTip || !pinkyTip) return; 

                const fingerDistance = Math.sqrt(
                    Math.pow(thumbTip.x - pinkyTip.x, 2) + Math.pow(thumbTip.y - pinkyTip.y, 2)
                );
                const minClosure = 0.05; 
                const maxOpen = 0.35;    
                const normalizedDistance = Math.min(1.0, Math.max(0.0, (fingerDistance - minClosure) / (maxOpen - minClosure)));
                rawScaleInput = 0.5 + normalizedDistance * 2.0; 
                const wrist = handLandmarks[0];
                
                currentHandPosition = new THREE.Vector3(
                    (0.5 - wrist.x) * SCENE_SENSITIVITY, 
                    (0.5 - wrist.y) * SCENE_SENSITIVITY, 0 
                );
            } 
            
            if (currentHandPosition) {
                const limit = 3.5;
                currentHandPosition.x = Math.min(limit, Math.max(-limit, currentHandPosition.x));
                currentHandPosition.y = Math.min(limit, Math.max(-limit, currentHandPosition.y));
                positionXHistory.push(currentHandPosition.x);
                positionYHistory.push(currentHandPosition.y);
                if (positionXHistory.length > WINDOW_SIZE) { positionXHistory.shift(); positionYHistory.shift(); }
                const smoothX = positionXHistory.reduce((a, b) => a + b, 0) / positionXHistory.length;
                const smoothY = positionYHistory.reduce((a, b) => a + b, 0) / positionYHistory.length;
                targetPosition.set(smoothX, smoothY, 0);
                scaleHistory.push(rawScaleInput);
                if (scaleHistory.length > WINDOW_SIZE) { scaleHistory.shift(); }
                const smoothScale = scaleHistory.reduce((a, b) => a + b, 0) / scaleHistory.length;
                targetScale = Math.min(3.5, Math.max(0.5, smoothScale)); 

                lastMotionTime = Date.now();

            } else {
                targetScale = 1.0; 
                targetPosition.set(0, 0, 0); 
                scaleHistory = [];
                positionXHistory = [];
                positionYHistory = [];
            }
        }

        function triggerFirework() {
              if (!Params.enableFireworks) return;

            const fireworkGeometry = new THREE.BufferGeometry();
            const positions = ParticleModels.Firework(Params.fireworkDensity, Params.fireworkSpread);
            fireworkGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const colors = new Float32Array(Params.fireworkDensity * 3);
            const fireworkColor = new THREE.Color(Math.random() * 0xffffff); 
            for (let i = 0; i < Params.fireworkDensity; i++) {
                colors[i * 3 + 0] = fireworkColor.r;
                colors[i * 3 + 1] = fireworkColor.g;
                colors[i * 3 + 2] = fireworkColor.b;
            }
            fireworkGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.1, 
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false 
            });

            const fireworkMesh = new THREE.Points(fireworkGeometry, material);
            
            const range = 8.0 * 1.5; 
            fireworkMesh.position.set(
                (Math.random() - 0.5) * 2 * range,
                (Math.random() - 0.5) * 2 * range,
                (Math.random() - 0.5) * 2 * range
            );
            scene.add(fireworkMesh);

            fireworks.push({
                mesh: fireworkMesh,
                startTime: Date.now(),
                lifetime: Params.fireworkLifetime * 1000 
            });
        }
        
        async function setupMediaPipe() {
            const videoElement = document.getElementById('webcam-video');

            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1, 
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults); 

            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                      throw new Error("æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´ APIã€‚");
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoElement.srcObject = stream;
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = resolve;
                });
                videoElement.play();

                const cameraMP = new Camera(videoElement, {
                    onFrame: async () => {
                        if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
                            await hands.send({ image: videoElement });
                        }
                    },
                    width: 1280, 
                    height: 720
                });

                cameraMP.start();
                console.log("MediaPipe ç»å…¸ Hands API å¯åŠ¨æˆåŠŸï¼Œæ­£åœ¨ç­‰å¾…è§†é¢‘æµ...");

            } catch (err) {
                console.error("MediaPipe åˆå§‹åŒ–å¤±è´¥æˆ–æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:", err);
                console.warn("è¯·æ£€æŸ¥æ‚¨çš„æ‘„åƒå¤´æƒé™ã€ç½‘ç»œè¿æ¥å’Œæµè§ˆå™¨æ§åˆ¶å°æ˜¯å¦æœ‰é”™è¯¯ã€‚");
            }
        }

        // --- éŸ³ä¹æ§åˆ¶ ---
        const bgMusic = document.getElementById('background-music');
        const musicBtn = document.getElementById('music-control-btn');

        function setupMusicControls() {
            musicBtn.addEventListener('click', () => {
                if (musicPlaying) {
                    bgMusic.pause();
                    musicBtn.textContent = 'â–¶ï¸ æ’­æ”¾èƒŒæ™¯éŸ³ä¹ (çƒ­å¸¦é›¨æ—)';
                    musicBtn.style.backgroundColor = 'rgba(255, 100, 100, 0.8)';
                } else {
                    // å°è¯•æ’­æ”¾ï¼Œæµè§ˆå™¨å¯èƒ½éœ€è¦ç”¨æˆ·äº¤äº’
                    bgMusic.play().then(() => {
                        musicBtn.textContent = 'â¸ï¸ æš‚åœèƒŒæ™¯éŸ³ä¹ (çƒ­å¸¦é›¨æ—)';
                        musicBtn.style.backgroundColor = 'rgba(100, 100, 100, 0.8)';
                    }).catch(error => {
                        console.warn("éŸ³ä¹æ’­æ”¾è¢«é˜»æ­¢ï¼Œéœ€è¦å†æ¬¡ç‚¹å‡»æˆ–ç”¨æˆ·äº¤äº’:", error);
                        musicBtn.textContent = 'â–¶ï¸ æ’­æ”¾èƒŒæ™¯éŸ³ä¹ (çƒ­å¸¦é›¨æ—)';
                        musicBtn.style.backgroundColor = 'rgba(255, 100, 100, 0.8)';
                    });
                }
                musicPlaying = !musicPlaying;
            });
        }
        
        function manageMusicVolume() {
            const musicVolume = bgMusic.volume;
            let targetVolume = 0.7; // é»˜è®¤å¤–éƒ¨éŸ³é‡
            const INSIDE_VOLUME = 0.2; // æ˜Ÿç³»å†…éƒ¨æŸ”å’ŒéŸ³é‡
            
            if (insideStar) {
                targetVolume = INSIDE_VOLUME;
            }

            // å¹³æ»‘è¿‡æ¸¡éŸ³é‡
            bgMusic.volume += (targetVolume - musicVolume) * 0.2;
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate(time) {
            requestAnimationFrame(animate);
            
            // 1. æ‰‹åŠ¿å’Œç¼©æ”¾å¤„ç†
            particleScale += (targetScale - particleScale) * 0.1;
            particlesPosition.lerp(targetPosition, SMOOTHING_FACTOR);

            const ENTER_THRESHOLD = 2.2; 
            const EXIT_THRESHOLD = 1.8;
            
            if (particleScale > ENTER_THRESHOLD && !insideStar) {
                cameraTargetZ = -0.5; 
                if(trailParticles) trailParticles.visible = false;
                insideStar = true;
                
            } else if (particleScale < EXIT_THRESHOLD && insideStar) {
                cameraTargetZ = 10; 
                if(trailParticles) trailParticles.visible = true;
                insideStar = false;
            }

            camera.position.z += (cameraTargetZ - camera.position.z) * 0.1;
            
            // 2. ç²’å­è¿åŠ¨
            orbitTime += Params.orbitSpeed;
            const orbitRadius = Params.orbitRadius * particleScale; 
            
            const starPos1 = new THREE.Vector3(
                orbitRadius * Math.cos(orbitTime),
                orbitRadius * Math.sin(orbitTime),
                0
            );
            const rotationMatrix = new THREE.Matrix4().makeRotationX(ORBIT_TILT_ANGLE);
            
            const currentStar1Pos = starPos1.clone().applyMatrix4(rotationMatrix).add(particlesPosition);
            
            const starPos2 = new THREE.Vector3(
                orbitRadius * Math.cos(orbitTime + Math.PI), 
                orbitRadius * Math.sin(orbitTime + Math.PI),
                0
            ).applyMatrix4(rotationMatrix).add(particlesPosition);
            
            if (star1 && star2) {
                star1.position.copy(currentStar1Pos);
                star2.position.copy(starPos2);
                
                star1.scale.set(particleScale, particleScale, particleScale);
                star2.scale.set(particleScale, particleScale, particleScale);
                star1.rotation.z += 0.005; 
                star2.rotation.z -= 0.005; 
            }


            // ğŸŒŸ è½¨è¿¹ç²’å­æ›´æ–°
            if (trailParticles && trailParticles.visible && trailParticles.geometry.attributes.position && trailParticles.userData.ages) {
                const positions = trailParticles.geometry.attributes.position.array;
                const ages = trailParticles.geometry.attributes.age.array;
                const colors = trailParticles.geometry.attributes.color.array;

                const trailColorBase = new THREE.Color(Params.trailColor);
                const trailDarkColor = new THREE.Color(0x000000); 
                const trailCount = ages.length;
                
                const direction = currentStar1Pos.clone().sub(lastStar1Position).normalize().negate(); 
                
                if (lastStar1Position.length() === 0 || direction.lengthSq() < 0.0001) {
                    direction.set(Math.cos(orbitTime + Math.PI*0.5), Math.sin(orbitTime + Math.PI*0.5), 0).negate().applyMatrix4(rotationMatrix);
                }

                for (let i = 0; i < trailCount; i++) {
                    ages[i]++;
                    
                    if (ages[i] > Params.trailLength) {
                        ages[i] = 0;
                        
                        const spread = Params.trailSpread * particleScale;
                        positions[i * 3] = currentStar1Pos.x + (Math.random() - 0.5) * spread * 0.1; 
                        positions[i * 3 + 1] = currentStar1Pos.y + (Math.random() - 0.5) * spread * 0.1;
                        positions[i * 3 + 2] = currentStar1Pos.z + (Math.random() - 0.5) * spread * 0.1;
                    }

                    const velocityFactor = (1 - ages[i] / Params.trailLength) * TRAIL_VELOCITY * particleScale; 
                    positions[i * 3] += direction.x * velocityFactor;
                    positions[i * 3 + 1] += direction.y * velocityFactor;
                    positions[i * 3 + 2] += direction.z * velocityFactor;
                    
                    const ageRatio = ages[i] / Params.trailLength; 
                    const fadedColor = new THREE.Color().copy(trailColorBase).lerp(trailDarkColor, ageRatio * 0.9); 
                    
                    colors[i * 3 + 0] = fadedColor.r;
                    colors[i * 3 + 1] = fadedColor.g;
                    colors[i * 3 + 2] = fadedColor.b;
                }

                trailParticles.geometry.attributes.position.needsUpdate = true;
                trailParticles.geometry.attributes.age.needsUpdate = true;
                trailParticles.geometry.attributes.color.needsUpdate = true; 
                
                lastStar1Position.copy(currentStar1Pos);
            }
            
            if (backgroundParticles) {
                backgroundParticles.rotation.y -= 0.0005;
            }


            // ğŸ–¼ï¸ å›¾ç‰‡æ˜¾ç¤º/éšè—å’Œæ—‹è½¬é€»è¾‘ 
            if (imagePlanes.length > 0) {
                const targetOpacity = insideStar ? 1.0 : 0.0;
                
                imagePlanes.forEach((plane, index) => {
                    plane.material.opacity += (targetOpacity - plane.material.opacity) * 0.1;
                    plane.lookAt(camera.position); 
                    const speed = 0.005 + Math.sin(index) * 0.001; 
                    plane.rotation.z += speed; 
                });
            }
            
            // ğŸ† çƒŸèŠ±é€»è¾‘
            const currentTime = Date.now();
            if (insideStar && Params.enableFireworks && (currentTime - lastFireworkTime > Params.fireworkInterval * 1000)) {
                triggerFirework();
                lastFireworkTime = currentTime;
            }
            
            // æ›´æ–°çƒŸèŠ±ç”Ÿå‘½å‘¨æœŸå’Œé€æ˜åº¦
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const f = fireworks[i];
                const age = currentTime - f.startTime;
                const lifeRatio = age / f.lifetime;

                if (lifeRatio > 1.0) {
                    scene.remove(f.mesh);
                    fireworks.splice(i, 1);
                } else {
                    f.mesh.material.opacity = 1.0 - lifeRatio; 
                    f.mesh.material.needsUpdate = true;
                }
            }
            
            // ğŸ¶ éŸ³ä¹éŸ³é‡æ§åˆ¶
            if (musicPlaying) {
                manageMusicVolume();
            }


            // --- æ¸²æŸ“éƒ¨åˆ† ---
            if (composer) {
                composer.render();
            } else if (renderer) {
                renderer.render(scene, camera);
            }
        }
        
        // =================================================================
        //                     åˆå§‹åŒ–å’Œäº‹ä»¶ç»‘å®š (åŒå­æ˜Ÿéƒ¨åˆ†)
        // =================================================================

        function init() {
            // 1. Scene setup
            const container = document.getElementById('container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = cameraTargetZ;

            // 2. Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 1);
            container.appendChild(renderer.domElement);

            // 3. Post-processing (Bloom)
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 
                                                        Params.bloomStrength, Params.bloomRadius, Params.bloomThreshold);

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 4. Initial Particle Systems
            star1 = updateParticleSystem(star1, 'Sphere', Params.starColor1, Params.starDensity, Params.targetSpread, Params.particleSize, true);
            star2 = updateParticleSystem(star2, 'Sphere', Params.starColor2, Params.starDensity, Params.targetSpread, Params.particleSize, true);
            trailParticles = updateParticleSystem(trailParticles, 'CometTrail', Params.trailColor, Params.trailDensity, Params.trailSpread, Params.trailSize, true);
            createBackgroundParticles();
            
            // 5. Load Images
            loadAllImagesAndCreatePlanes(IMAGE_FILES);

            // 6. DAT.GUI Controls
            const gui = new dat.GUI();
            gui.addColor(Params, 'starColor1').onChange(() => updateParticleSystem(star1, 'Sphere', Params.starColor1, Params.starDensity, Params.targetSpread, Params.particleSize));
            gui.addColor(Params, 'starColor2').onChange(() => updateParticleSystem(star2, 'Sphere', Params.starColor2, Params.starDensity, Params.targetSpread, Params.particleSize));
            gui.add(Params, 'particleSize', 0.01, 0.1).name('Star Size').onChange(() => {
                if(star1) star1.material.size = Params.particleSize;
                if(star2) star2.material.size = Params.particleSize;
            });
            gui.add(Params, 'targetSpread', 1, 5).name('Star Spread').onChange(() => {
                star1 = updateParticleSystem(star1, 'Sphere', Params.starColor1, Params.starDensity, Params.targetSpread, Params.particleSize);
                star2 = updateParticleSystem(star2, 'Sphere', Params.starColor2, Params.starDensity, Params.targetSpread, Params.particleSize);
            });
            gui.add(Params, 'orbitRadius', 1, 5).name('Orbit Radius');
            gui.add(Params, 'orbitSpeed', 0.001, 0.1).name('Orbit Speed');
            
            const bloomFolder = gui.addFolder('Bloom Effect');
            bloomFolder.add(Params, 'bloomStrength', 0, 5).name('Strength').onChange(value => bloomPass.strength = value);
            bloomFolder.add(Params, 'bloomRadius', 0, 2).name('Radius').onChange(value => bloomPass.radius = value);
            bloomFolder.add(Params, 'bloomThreshold', 0, 1).name('Threshold').onChange(value => bloomPass.threshold = value);
            bloomFolder.open();
            
            // 7. Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
            
            // 8. éŸ³ä¹äº‹ä»¶ç»‘å®š
            setupMusicControls();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
        
        // --- å¯åŠ¨å‡½æ•° ---
        document.addEventListener('DOMContentLoaded', () => {
            init();
            setupMediaPipe(); // å¯åŠ¨æ‘„åƒå¤´å’Œæ‰‹åŠ¿æ£€æµ‹
            createWindowsLoop(); // å¯åŠ¨æ¸©é¦¨æç¤ºå¾ªç¯
            animate();
        });
        
    </script>
</body>
</html>
```
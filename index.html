<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç²’å­æ‰‹åŠ¿äº¤äº’ Â· åŒå­æ˜Ÿ Â· æŠ›ç‰©çº¿å½—å°¾</title>
    <style>
        /* ======================================= */
        /* 1. Three.js åŸºç¡€æ ·å¼ */
        /* ======================================= */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas { display: block; }
        
        #fullscreen-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 8px 12px;
            background-color: rgba(30, 30, 30, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            cursor: pointer;
            z-index: 1000;
            transition: background-color 0.3s;
        }
        #fullscreen-btn:hover {
            background-color: rgba(60, 60, 60, 0.9);
        }

        /* éšè—æ‘„åƒå¤´è§†é¢‘æµ */
        #video-container {
            position: absolute;
            opacity: 0; 
            pointer-events: none;
            z-index: -1;
        }

        .dg.main {
            z-index: 1001 !important;
            top: 50px !important;
            border-radius: 5px;
            right: 15px !important; 
        }
        
        /* éŸ³ä¹æ§åˆ¶åŒºåŸŸ */
        #music-controls {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        .music-btn {
            padding: 8px 12px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            font-size: 14px;
        }
        
        #music-play-pause {
            background-color: rgba(255, 100, 100, 0.8);
        }
        
        #music-play-pause:hover {
            background-color: rgba(255, 50, 50, 1);
        }
        
        #music-switch {
            background-color: rgba(100, 100, 255, 0.8);
        }
        
        #music-switch:hover {
            background-color: rgba(50, 50, 255, 1);
        }
        
        #current-music {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 4px;
            color: #ffd700;
            font-size: 14px;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        /* ======================================= */
        /* 2. æ¸©é¦¨æç¤º CSS æ ·å¼ */
        /* ======================================= */
        
        /* æ¨¡æ‹Ÿæç¤ºçª—å£çš„æ ·å¼ */
        .tip-window {
            position: fixed; 
            width: 300px;
            height: 90px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            font-family: 'å¾®è½¯é›…é»‘', sans-serif;
            font-size: 16px;
            color: #333;
            opacity: 0; 
            transition: opacity 0.5s, transform 0.5s; 
            z-index: 500;
        }

        /* å›¾ç‰‡å¼¹çª—æ ·å¼ */
        .image-popup {
            position: fixed;
            width: 300px;
            height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6), 0 0 20px rgba(255, 255, 255, 0.3);
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            z-index: 600;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }
        
        .image-popup img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* æœ€ç»ˆçª—å£çš„æ ·å¼ */
        #final-window {
            position: fixed;
            width: 400px;
            height: 120px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: lightpink;
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: none; 
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            box-shadow: 0 0 30px lightpink;
            opacity: 0;
            transition: opacity 1s;
            z-index: 2000; 
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="video-container">
        <video id="webcam-video" playsinline></video> 
    </div>
    
    <!-- éŸ³ä¹æ§åˆ¶åŒºåŸŸ -->
    <div id="music-controls">
        <button id="music-play-pause" class="music-btn">â–¶ï¸ æ’­æ”¾</button>
        <button id="music-switch" class="music-btn">ğŸ”„ åˆ‡æ¢éŸ³ä¹</button>
        <span id="current-music">ğŸµ æ­Œæ›² 1/2</span>
    </div>
    
    <button id="fullscreen-btn">å…¨å±</button>

    <div id="final-window">
        æˆ‘æƒ³ä½ äº†
    </div>

    <!-- ä¸¤é¦–èƒŒæ™¯éŸ³ä¹ -->
    <audio id="background-music-1" loop preload="auto">
        <source src="tropical_rainforest.mp3" type="audio/mpeg">
        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
    </audio>
    
    <audio id="background-music-2" loop preload="auto">
        <!-- è¯·å°†ç¬¬äºŒé¦–éŸ³ä¹æ–‡ä»¶æ”¾åœ¨åŒç›®å½•ä¸‹ -->
        <source src="second_music.mp3" type="audio/mpeg">
        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script> 

    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/RGBShiftShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script>
        // =================================================================
        //                 çƒŸèŠ±å¯è°ƒå‚æ•° - ç›´æ¥åœ¨è¿™é‡Œä¿®æ”¹æ•°å€¼
        // =================================================================
        const FIREWORK_PARAMS = {
            particleSize: 0.02,      // ç²’å­å¤§å°
            particleCount: 50000,     // ç²’å­æ•°é‡
            brightness: 10.0          // äº®åº¦ç³»æ•°
        };

        // =================================================================
        //                 éŸ³ä¹é…ç½®å‚æ•°
        // =================================================================
        const MUSIC_CONFIG = {
            currentTrack: 1,
            musicFiles: [
                'tropical_rainforest.mp3',
                'second_music.mp3'
            ],
            musicNames: [
                'æˆ‘ä»¬ä¸€èµ·æ‹çˆ±å§',
                'ç¬¬äºŒé¦–éŸ³ä¹'
            ]
        };

        // =================================================================
        //                 çƒŸèŠ±é…ç½®å‚æ•° - å¯è‡ªç”±è°ƒæ•´
        // =================================================================
        const FIREWORK_CONFIG = {
            maxConcurrentFireworks: 50,
            useRandomPositions: true,
            randomPositionRange: {
                x: 14,
                yMin: 6,
                yMax: 14,
                z: 14
            },
            launchIntervalMin: 300,
            launchIntervalMax: 4000,
            rocketSpeedMin: 0.12,
            rocketSpeedMax: 0.25,
            trailLength: 120
        };

        // =================================================================
        //                 å½—æ˜Ÿå°¾å·´å‚æ•° - æŠ›ç‰©çº¿æ•ˆæœ
        // =================================================================
        const COMET_TRAIL_CONFIG = {
            // å°¾å·´æ•°é‡
            trailCount: 16,
            
            // æ¯æ¡å°¾å·´çš„ç²’å­æ•°é‡
            particlesPerTrail: 7000,
            
            // æ˜Ÿçƒç›´å¾„
            starDiameter: 3.0,
            
            // å°¾å·´é•¿åº¦
            maxTrailLength: 8.0,
            
            // æŠ›ç‰©çº¿é«˜åº¦ - ä¸æ—‹è½¬æ–¹å‘ç›¸å
            parabolaHeight: 4.0,
            
            // å¼¯æ›²æ–¹å‘ - ä¸æ—‹è½¬æ–¹å‘ç›¸å
            curveDirection: -1,  // -1 è¡¨ç¤ºåå‘å¼¯æ›²
            
            // äº®åº¦å‚æ•°
            baseBrightness: 0.6,
            brightnessFalloff: 2.5,
            
            // ç²’å­å¤§å°
            particleSize: 0.01
        };

        // =================================================================
        //                 å…¨å±€å˜é‡å’Œå‚æ•°è®¾ç½®
        // =================================================================
        let scene, camera, renderer, composer; 
        let star1, star2, backgroundParticles; 
        let cometTrails1 = [];
        let cometTrails2 = [];
        let imagePlanes = [];
        let imagePopups = [];
        let fireworks = [];               
        let rockets = [];                  
        let nextLaunchTime = 0;        
        let lastFireworkTime = 0; 
        let lastMotionTime = 0; 
        let orbitTime = 0; 
        let cameraTargetZ = 10; 
        let insideStar = false; 
        let finalTipShown = false;
        let musicPlaying = false; 

        const ORBIT_TILT_ANGLE = Math.PI * 0.11; 
        const TRAIL_VELOCITY = 0.12;

        const Params = {
            starColor1: 0x81C7E6, starColor2: 0xEFC4C4, particleSize: 0.031, targetSpread: 3.5, 
            starDensity: 14000, orbitRadius: 2.8, orbitSpeed: 0.012,
            exposure: 1.2, bloomStrength: 1.7, bloomThreshold: 0.7, bloomRadius: 0.98
        };

        const IMAGE_FILES = [
            'IMG_20251008_180842.jpg', 'light_shadow_border_1758868022928.jpg', 
            'mmexport1759924058791.jpg', 'mmexport1759924088470.jpg', 
            'mmexport1759924093473.jpg', 'mmexport1759924102487.jpg', 
            'mmexport1764822928436.jpg', 'mmexport1764822953695.jpg', 
            'mmexport1764822958536.jpg', 'mmexport1764822966406.jpg', 
            'mmexport1764822967696.jpg', 'mmexport1764822970360.jpg', 
            'mmexport1764822973131.jpg', 'mmexport1764822974719.jpg', 
            'mmexport1764822984508.jpg', 'mmexport1764823046062.jpg', 
            'mmexport1764823054048.jpg', 'mmexport1764823065525.jpg', 
            'mmexport1764823101912.jpg', 'mmexport1764823110358.jpg', 
            'mmexport1764823157249.jpg', 'mmexport1764823175328.jpg',
            '2531d7b30f76c414d2f0ed63ffe5c4c2.jpg','352bcb9d3d44f4a314be701580901ac3.jpg','1f11e4a5e6e8a09df676b8c9dda14a15.jpg',
            '3940783d25012a2c2895c442c966a52f.jpg','a908a75ffa0527a1542577b0d8521277.jpg','cae73ce1d6716a25d449d7440601352c.jpg',
        ];
        
        const IMAGE_BASE_PATH = ''; 

        let particleScale = 1.0; 
        let targetScale = 1.0;   
        let particlesPosition = new THREE.Vector3(0, 0, 0); 
        let targetPosition = new THREE.Vector3(0, 0, 0);    
        const SMOOTHING_FACTOR = 0.15; 
        const WINDOW_SIZE = 5; 
        let scaleHistory = [];
        let positionXHistory = [];
        let positionYHistory = [];

        // =================================================================
        //                 éŸ³ä¹æ§åˆ¶å‡½æ•°
        // =================================================================
        const musicElements = [
            document.getElementById('background-music-1'),
            document.getElementById('background-music-2')
        ];
        
        const musicPlayPauseBtn = document.getElementById('music-play-pause');
        const musicSwitchBtn = document.getElementById('music-switch');
        const currentMusicSpan = document.getElementById('current-music');

        function updateMusicDisplay() {
            currentMusicSpan.textContent = `ğŸµ ${MUSIC_CONFIG.musicNames[MUSIC_CONFIG.currentTrack - 1]}`;
        }

        function switchMusic() {
            if (musicPlaying) {
                musicElements[MUSIC_CONFIG.currentTrack - 1].pause();
            }
            
            MUSIC_CONFIG.currentTrack = MUSIC_CONFIG.currentTrack === 1 ? 2 : 1;
            
            updateMusicDisplay();
            
            if (musicPlaying) {
                musicElements[MUSIC_CONFIG.currentTrack - 1].play().catch(error => {
                    console.warn("éŸ³ä¹æ’­æ”¾å¤±è´¥:", error);
                    musicPlaying = false;
                    musicPlayPauseBtn.textContent = 'â–¶ï¸ æ’­æ”¾';
                });
            }
            
            const targetVolume = insideStar ? 0.2 : 0.7;
            musicElements[MUSIC_CONFIG.currentTrack - 1].volume = targetVolume;
        }

        function toggleMusic() {
            const currentMusic = musicElements[MUSIC_CONFIG.currentTrack - 1];
            
            if (musicPlaying) {
                currentMusic.pause();
                musicPlayPauseBtn.textContent = 'â–¶ï¸ æ’­æ”¾';
            } else {
                currentMusic.play().then(() => {
                    musicPlayPauseBtn.textContent = 'â¸ï¸ æš‚åœ';
                }).catch(error => {
                    console.warn("éŸ³ä¹æ’­æ”¾å¤±è´¥:", error);
                    musicPlayPauseBtn.textContent = 'â–¶ï¸ æ’­æ”¾';
                });
            }
            musicPlaying = !musicPlaying;
        }
        
        function manageMusicVolume() {
            if (!musicPlaying) return;
            
            const currentMusic = musicElements[MUSIC_CONFIG.currentTrack - 1];
            const musicVolume = currentMusic.volume;
            let targetVolume = 0.7;
            const INSIDE_VOLUME = 0.2;
            
            if (insideStar) {
                targetVolume = INSIDE_VOLUME;
            }

            currentMusic.volume += (targetVolume - musicVolume) * 0.2;
        }

        function setupMusicControls() {
            musicPlayPauseBtn.addEventListener('click', toggleMusic);
            musicSwitchBtn.addEventListener('click', switchMusic);
            
            updateMusicDisplay();
            
            musicElements.forEach(music => {
                music.load();
            });
        }

        // =================================================================
        //                 æ¸©é¦¨æç¤ºå’Œå›¾ç‰‡å¼¹çª—å‡½æ•° 
        // =================================================================
        const W_TIPS = [
            'å¤šå–æ°´å“¦~', 'å°å¿ƒæˆ‘æä½ ', 'å“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå¯çˆ±','æˆ‘å®³æ€•','åƒé¥±äº†','åƒé¥±äº†','å¥½å®å®','æˆ‘å¯æ˜¯å¤§ç‹','å°çŒª',
            'åƒæ°´æœ', 'ä¿æŒå¥½å¿ƒæƒ…', 'å¥½å¥½çˆ±è‡ªå·±', 'æˆ‘æƒ³ä½ äº†','æœ‰å®åŠ›å“¦','ç­‰å¾…~','ç•¥ç•¥','å˜»å˜»',
            'æ¢¦æƒ³æˆçœŸ', 'æœŸå¾…ä¸‹ä¸€æ¬¡è§é¢', 'è¾›è‹¦äº†~', 'è®²å“©æ»´','é€—é€—ä½ ','çƒ§é¸­ç²‰~','å¥½å¹¸ç¦','æ•™å®˜å®˜',
            'æ„¿æ‰€æœ‰çƒ¦æ¼éƒ½æ¶ˆå¤±', 'ç­”åº”æˆ‘æ—©ç‚¹ç¡', 'æŠŠè¢«å­ç›–å¥½', 'å¤©å†·äº†ï¼Œå¤šç©¿è¡£æœ'
        ];
        
        const W_COLORS = [
            'lightpink', 'skyblue', 'lightgreen', 'lavender',
            'lightyellow', 'plum', 'coral', 'bisque', 'aquamarine',
            'mistyrose', 'honeydew', 'lavenderblush', 'oldlace'
        ];

        const W_CREATE_INTERVAL = 50; 
        const W_PROBABILITY = 0.5;    
        const W_CENTER_EXCLUSION = 400; 
        
        const w_finalWindowElement = document.getElementById('final-window');

        const preloadedImages = [];
        function preloadImages() {
            IMAGE_FILES.forEach(filename => {
                const img = new Image();
                img.src = IMAGE_BASE_PATH + filename;
                preloadedImages.push(img);
            });
        }

        function createTipWindow() {
            const W_WIDTH = 300;
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const centerMargin = (screenWidth - W_CENTER_EXCLUSION) / 2;
            
            const tip = W_TIPS[Math.floor(Math.random() * W_TIPS.length)];
            const bg = W_COLORS[Math.floor(Math.random() * W_COLORS.length)];

            let x;
            if (Math.random() < 0.5) {
                x = Math.random() * (centerMargin - W_WIDTH);
            } else {
                x = centerMargin + W_CENTER_EXCLUSION + Math.random() * (screenWidth - (centerMargin + W_CENTER_EXCLUSION) - W_WIDTH);
            }
            
            const y = Math.random() * (screenHeight - 90);

            const windowDiv = document.createElement('div');
            windowDiv.className = 'tip-window';
            windowDiv.textContent = tip;
            windowDiv.style.backgroundColor = bg;
            windowDiv.style.left = `${x}px`;
            windowDiv.style.top = `${y}px`;
            
            document.body.appendChild(windowDiv);
            
            setTimeout(() => {
                windowDiv.style.opacity = '1';
            }, 50);

            const closeDelay = Math.random() * 2000 + 1000; 

            setTimeout(() => {
                windowDiv.style.opacity = '0';
                windowDiv.style.transform = 'scale(0.8)'; 
                
                setTimeout(() => {
                    if (windowDiv.parentElement) {
                        windowDiv.parentElement.removeChild(windowDiv);
                    }
                }, 500); 
            }, closeDelay);

            if (Math.random() < 0.01 && !finalTipShown) {
                createFinalWindow();
            }
        }

        function createImagePopup() {
            if (preloadedImages.length === 0) return;
            
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            
            const imgIndex = Math.floor(Math.random() * preloadedImages.length);
            const imgSrc = preloadedImages[imgIndex].src;
            
            const POPUP_WIDTH = 300;
            const centerMargin = (screenWidth - W_CENTER_EXCLUSION) / 2;
            
            let x;
            if (Math.random() < 0.5) {
                x = Math.random() * Math.max(0, centerMargin - POPUP_WIDTH);
            } else {
                x = centerMargin + W_CENTER_EXCLUSION + Math.random() * Math.max(0, screenWidth - (centerMargin + W_CENTER_EXCLUSION) - POPUP_WIDTH);
            }
            
            const y = Math.random() * (screenHeight - 300);
            
            const popupDiv = document.createElement('div');
            popupDiv.className = 'image-popup';
            
            const img = document.createElement('img');
            img.src = imgSrc;
            popupDiv.appendChild(img);
            
            popupDiv.style.left = `${x}px`;
            popupDiv.style.top = `${y}px`;
            popupDiv.style.transform = 'scale(0.8)';
            
            document.body.appendChild(popupDiv);
            
            setTimeout(() => {
                popupDiv.style.opacity = '1';
                popupDiv.style.transform = 'scale(1)';
            }, 50);
            
            const duration = 2000 + Math.random() * 3000;
            
            setTimeout(() => {
                popupDiv.style.opacity = '0';
                popupDiv.style.transform = 'scale(0.8)';
                
                setTimeout(() => {
                    if (popupDiv.parentElement) {
                        popupDiv.parentElement.removeChild(popupDiv);
                    }
                }, 500);
            }, duration);
        }

        function createFinalWindow() {
            if (finalTipShown) return;
            finalTipShown = true; 
            w_finalWindowElement.style.display = 'flex'; 
            
            setTimeout(() => {
                w_finalWindowElement.style.opacity = '1';
            }, 50);
        }

        function createWindowsLoop() {
            if (insideStar) {
                if (Math.random() < 0.8) {
                    createImagePopup();
                }
                setTimeout(createWindowsLoop, 300);
                return;
            }

            if (Math.random() < W_PROBABILITY) {
                createTipWindow();
            }
            
            setTimeout(createWindowsLoop, W_CREATE_INTERVAL);
        }
        
        // =================================================================
        //                     æ ¸å¿ƒåŠŸèƒ½å‡½æ•°å®šä¹‰
        // =================================================================
        
        const ParticleModels = {
            Sphere: (count, spread) => { 
                const pos = [];
                for (let i = 0; i < count; i++) {
                    const radius = Math.cbrt(Math.random()) * spread; 
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(Math.random() * 2 - 1);
                    pos.push(radius * Math.sin(phi) * Math.cos(theta));
                    pos.push(radius * Math.sin(phi) * Math.sin(theta));
                    pos.push(radius * Math.cos(phi));
                }
                return pos;
            }
        };

        // åˆ›å»ºå½—æ˜Ÿå°¾å·´çº¹ç†
        function createCometTrailTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 8;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createLinearGradient(0, 0, 0, 64);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(200, 200, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(150, 150, 255, 0.4)');
            gradient.addColorStop(0.8, 'rgba(100, 100, 255, 0.1)');
            gradient.addColorStop(1, 'rgba(50, 50, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 8, 64);
            
            return new THREE.CanvasTexture(canvas);
        }

        function createBackgroundParticles() {
            const bgGeometry = new THREE.BufferGeometry();
            const bgPositions = [];
            const bgCount = 500;
            for (let i = 0; i < bgCount; i++) {
                bgPositions.push((Math.random() - 0.5) * 100); 
                bgPositions.push((Math.random() - 0.5) * 100);
                bgPositions.push((Math.random() - 0.5) * 100);
            }
            bgGeometry.setAttribute('position', new THREE.Float32BufferAttribute(bgPositions, 3));
            const bgMaterial = new THREE.PointsMaterial({
                color: 0x555555,
                size: 0.1,
                sizeAttenuation: true
            });
            backgroundParticles = new THREE.Points(bgGeometry, bgMaterial);
            scene.add(backgroundParticles);
        }

        function updateParticleSystem(targetObject, modelName, color, density, spread, size, isInitial = false) {
            const newPositions = ParticleModels[modelName](density, spread);
            const particleCount = newPositions.length / 3;
            
            const colors = new Float32Array(particleCount * 3);
            const baseColor = new THREE.Color(color);
            const centerColor = new THREE.Color(0xFFFFFF); 

            for (let i = 0; i < particleCount; i++) {
                const x = newPositions[i * 3];
                const y = newPositions[i * 3 + 1];
                const z = newPositions[i * 3 + 2];
                const distance = Math.sqrt(x*x + y*y + z*z);
                const distanceRatio = distance / spread; 
                
                const finalColor = new THREE.Color();
                finalColor.copy(baseColor).lerp(centerColor, 1 - distanceRatio); 

                colors[i * 3 + 0] = finalColor.r;
                colors[i * 3 + 1] = finalColor.g;
                colors[i * 3 + 2] = finalColor.b;
            }

            const particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(newPositions), 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: size,
                vertexColors: true, 
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false, 
                sizeAttenuation: true
            });

            if (targetObject) scene.remove(targetObject);
            targetObject = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(targetObject);
            return targetObject;
        }

        // è®¡ç®—æŠ›ç‰©çº¿ä½ç½® - ä¸æ—‹è½¬æ–¹å‘ç›¸å
        function calculateParabolaPosition(distance, angle, starPos, outwardDir, rotationDir) {
            // è·ç¦»å› å­
            const t = Math.min(1, distance / COMET_TRAIL_CONFIG.maxTrailLength);
            
            // æŠ›ç‰©çº¿å¼¯æ›² - ä¸æ—‹è½¬æ–¹å‘ç›¸å
            const curveAmount = COMET_TRAIL_CONFIG.curveDirection * COMET_TRAIL_CONFIG.parabolaHeight * (t * t);
            
            // è®¡ç®—å‘å¤–æ–¹å‘çš„å‚ç›´å‘é‡
            const up = new THREE.Vector3(0, 1, 0);
            const right = new THREE.Vector3().crossVectors(outwardDir, up).normalize();
            
            // ç¡®ä¿ right å‘é‡æœ‰æ•ˆ
            if (right.length() < 0.1) {
                right.set(1, 0, 0);
            }
            
            // åœ¨å‘å¤–æ–¹å‘ä¸Šç§»åŠ¨ç²’å­
            const forward = outwardDir.clone().multiplyScalar(distance);
            
            // æŠ›ç‰©çº¿å¼¯æ›² - ä½¿ç”¨æ—‹è½¬æ–¹å‘æ¥å†³å®šå¼¯æ›²æ–¹å‘
            const bendDir = rotationDir.clone().normalize();
            const parabolicBend = bendDir.clone().multiplyScalar(curveAmount);
            
            // åœ†å‘¨åˆ†å¸ƒ - ä¿æŒä¸æ˜Ÿçƒç›´å¾„ç›¸åŒçš„å®½åº¦
            const trailWidth = COMET_TRAIL_CONFIG.starDiameter;
            const lateralOffset = Math.cos(angle) * trailWidth * 0.5;
            const verticalOffset = Math.sin(angle) * trailWidth * 0.25;
            
            const lateralDir = right.clone().multiplyScalar(lateralOffset);
            const verticalDir = up.clone().multiplyScalar(verticalOffset);
            
            // åˆæˆæœ€ç»ˆä½ç½®
            return starPos.clone()
                .add(forward)
                .add(parabolicBend)
                .add(lateralDir)
                .add(verticalDir);
        }

        // åˆ›å»ºä¸€æ¡å½—æ˜Ÿå°¾å·´ - æŠ›ç‰©çº¿æ•ˆæœ
        function createCometTrail(color, index, totalTrails) {
            const particlesPerTrail = COMET_TRAIL_CONFIG.particlesPerTrail;
            
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particlesPerTrail * 3);
            const ages = new Float32Array(particlesPerTrail);
            const colors = new Float32Array(particlesPerTrail * 3);
            
            const baseColor = new THREE.Color(color);
            
            // æ¯æ¡å°¾å·´æœ‰ä¸åŒçš„èµ·å§‹è§’åº¦
            const startAngle = (index / totalTrails) * Math.PI * 2;
            
            for (let i = 0; i < particlesPerTrail; i++) {
                // è·ç¦»å› å­ (0 é è¿‘æ˜Ÿçƒ, 1 æœ€è¿œ)
                const distanceFactor = i / particlesPerTrail;
                
                // ç²’å­è§’åº¦ä¿æŒä¸å˜ï¼ˆæ— èºæ—‹ï¼‰
                const particleAngle = startAngle;
                
                // åˆå§‹ä½ç½®
                positions[i*3] = 0;
                positions[i*3+1] = 0;
                positions[i*3+2] = 0;
                
                // å¹´é¾„éšæœºåˆ†å¸ƒ - å¹´é¾„è¶Šå¤§ï¼Œè·ç¦»è¶Šè¿œ
                ages[i] = Math.random() * 100 * (1 - distanceFactor * 0.5);
                
                // äº®åº¦è¡°å‡
                const brightnessFactor = COMET_TRAIL_CONFIG.baseBrightness * 
                                        Math.pow(1 - distanceFactor, COMET_TRAIL_CONFIG.brightnessFalloff);
                
                colors[i*3] = baseColor.r * brightnessFactor;
                colors[i*3+1] = baseColor.g * brightnessFactor;
                colors[i*3+2] = baseColor.b * brightnessFactor;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('age', new THREE.BufferAttribute(ages, 1));
            
            const material = new THREE.PointsMaterial({
                size: COMET_TRAIL_CONFIG.particleSize,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                map: createCometTrailTexture(),
                depthWrite: false,
                transparent: true,
                sizeAttenuation: true
            });
            
            const trail = new THREE.Points(geometry, material);
            
            trail.userData = {
                ages: ages,
                startAngle: startAngle,
                particlesPerTrail: particlesPerTrail,
                baseColor: baseColor.clone(),
                colors: colors
            };
            
            return trail;
        }

        // åˆ›å»ºæ‰€æœ‰å½—æ˜Ÿå°¾å·´
        function createAllCometTrails() {
            const trailCount = COMET_TRAIL_CONFIG.trailCount;
            
            for (let i = 0; i < trailCount; i++) {
                const trail1 = createCometTrail(Params.starColor1, i, trailCount);
                scene.add(trail1);
                cometTrails1.push(trail1);
                
                const trail2 = createCometTrail(Params.starColor2, i, trailCount);
                scene.add(trail2);
                cometTrails2.push(trail2);
            }
        }

        // æ›´æ–°å½—æ˜Ÿå°¾å·´ - æŠ›ç‰©çº¿æ•ˆæœ
        function updateCometTrails(deltaSec) {
            if (!star1 || !star2) return;
            
            const particlesPerTrail = COMET_TRAIL_CONFIG.particlesPerTrail;
            
            // è®¡ç®—å‘å¤–å‘å°„æ–¹å‘
            const outwardDir1 = star1.position.clone().sub(particlesPosition).normalize();
            const outwardDir2 = star2.position.clone().sub(particlesPosition).normalize();
            
            // è®¡ç®—æ—‹è½¬æ–¹å‘ - ç”¨äºæŠ›ç‰©çº¿å¼¯æ›²
            // æ ¹æ®è½¨é“é€Ÿåº¦è®¡ç®—åˆ‡çº¿æ–¹å‘
            const tangent1 = new THREE.Vector3(-Math.sin(orbitTime), Math.cos(orbitTime), 0).applyMatrix4(new THREE.Matrix4().makeRotationX(ORBIT_TILT_ANGLE));
            const tangent2 = new THREE.Vector3(-Math.sin(orbitTime + Math.PI), Math.cos(orbitTime + Math.PI), 0).applyMatrix4(new THREE.Matrix4().makeRotationX(ORBIT_TILT_ANGLE));
            
            // æ›´æ–°ç¬¬ä¸€é¢—æ˜Ÿçš„æ‰€æœ‰å°¾å·´
            cometTrails1.forEach((trail, trailIndex) => {
                const positions = trail.geometry.attributes.position.array;
                const ages = trail.userData.ages;
                const colors = trail.geometry.attributes.color.array;
                const startAngle = trail.userData.startAngle;
                const baseColor = trail.userData.baseColor;
                
                for (let i = 0; i < particlesPerTrail; i++) {
                    // å¹´é¾„å¢åŠ 
                    ages[i] += deltaSec * 30;
                    
                    // è·ç¦»å› å­
                    const distanceFactor = i / particlesPerTrail;
                    
                    if (ages[i] > 100) {
                        ages[i] = 0;
                        
                        // é‡ç½®ç²’å­åˆ°æ˜Ÿçƒè¾¹ç¼˜
                        const resetDistance = COMET_TRAIL_CONFIG.starDiameter / 2;
                        
                        const pos = calculateParabolaPosition(
                            resetDistance, 
                            startAngle, 
                            star1.position, 
                            outwardDir1,
                            tangent1  // ä¼ å…¥æ—‹è½¬æ–¹å‘
                        );
                        
                        positions[i*3] = pos.x;
                        positions[i*3+1] = pos.y;
                        positions[i*3+2] = pos.z;
                    } else {
                        // æ ¹æ®å¹´é¾„è®¡ç®—å½“å‰ä½ç½®
                        const ageRatio = ages[i] / 100;
                        
                        // å¹´é¾„è¶Šå¤§ï¼Œè·ç¦»è¶Šè¿œ
                        const currentDistance = (COMET_TRAIL_CONFIG.starDiameter / 2) + 
                                               (COMET_TRAIL_CONFIG.maxTrailLength - COMET_TRAIL_CONFIG.starDiameter / 2) * 
                                               ageRatio;
                        
                        const pos = calculateParabolaPosition(
                            currentDistance,
                            startAngle,
                            star1.position,
                            outwardDir1,
                            tangent1  // ä¼ å…¥æ—‹è½¬æ–¹å‘
                        );
                        
                        positions[i*3] = pos.x;
                        positions[i*3+1] = pos.y;
                        positions[i*3+2] = pos.z;
                    }
                    
                    // äº®åº¦è¡°å‡
                    const ageRatio = ages[i] / 100;
                    const brightnessFactor = COMET_TRAIL_CONFIG.baseBrightness * 
                                            Math.pow(1 - distanceFactor, COMET_TRAIL_CONFIG.brightnessFalloff) *
                                            (1 - ageRatio * 0.3);
                    
                    colors[i*3] = baseColor.r * brightnessFactor;
                    colors[i*3+1] = baseColor.g * brightnessFactor;
                    colors[i*3+2] = baseColor.b * brightnessFactor;
                }
                
                trail.geometry.attributes.position.needsUpdate = true;
                trail.geometry.attributes.color.needsUpdate = true;
            });
            
            // æ›´æ–°ç¬¬äºŒé¢—æ˜Ÿçš„æ‰€æœ‰å°¾å·´
            cometTrails2.forEach((trail, trailIndex) => {
                const positions = trail.geometry.attributes.position.array;
                const ages = trail.userData.ages;
                const colors = trail.geometry.attributes.color.array;
                const startAngle = trail.userData.startAngle;
                const baseColor = trail.userData.baseColor;
                
                for (let i = 0; i < particlesPerTrail; i++) {
                    ages[i] += deltaSec * 30;
                    
                    const distanceFactor = i / particlesPerTrail;
                    
                    if (ages[i] > 100) {
                        ages[i] = 0;
                        
                        const resetDistance = COMET_TRAIL_CONFIG.starDiameter / 2;
                        
                        const pos = calculateParabolaPosition(
                            resetDistance, 
                            startAngle, 
                            star2.position, 
                            outwardDir2,
                            tangent2  // ä¼ å…¥æ—‹è½¬æ–¹å‘
                        );
                        
                        positions[i*3] = pos.x;
                        positions[i*3+1] = pos.y;
                        positions[i*3+2] = pos.z;
                    } else {
                        const ageRatio = ages[i] / 100;
                        const currentDistance = (COMET_TRAIL_CONFIG.starDiameter / 2) + 
                                               (COMET_TRAIL_CONFIG.maxTrailLength - COMET_TRAIL_CONFIG.starDiameter / 2) * 
                                               ageRatio;
                        
                        const pos = calculateParabolaPosition(
                            currentDistance,
                            startAngle,
                            star2.position,
                            outwardDir2,
                            tangent2  // ä¼ å…¥æ—‹è½¬æ–¹å‘
                        );
                        
                        positions[i*3] = pos.x;
                        positions[i*3+1] = pos.y;
                        positions[i*3+2] = pos.z;
                    }
                    
                    const ageRatio = ages[i] / 100;
                    const brightnessFactor = COMET_TRAIL_CONFIG.baseBrightness * 
                                            Math.pow(1 - distanceFactor, COMET_TRAIL_CONFIG.brightnessFalloff) *
                                            (1 - ageRatio * 0.3);
                    
                    colors[i*3] = baseColor.r * brightnessFactor;
                    colors[i*3+1] = baseColor.g * brightnessFactor;
                    colors[i*3+2] = baseColor.b * brightnessFactor;
                }
                
                trail.geometry.attributes.position.needsUpdate = true;
                trail.geometry.attributes.color.needsUpdate = true;
            });
        }

        // =================================================================
        // MediaPipe æ‰‹åŠ¿å¤„ç†
        // =================================================================
        function onResults(results) {
            let rawScaleInput = 1.0;
            let currentHandPosition = null;

            const detectedHands = results.multiHandLandmarks; 
            const handCount = detectedHands ? detectedHands.length : 0;
            const SCENE_SENSITIVITY = 8; 
            const limit = 3.5;
            
            if (handCount >= 2) {
                const hand1 = detectedHands[0];
                const hand2 = detectedHands[1];
                const wrist1 = hand1[0];
                const wrist2 = hand2[0]; 
                
                if (!wrist1 || !wrist2) return; 
                
                const handDistance = Math.sqrt(
                    Math.pow(wrist1.x - wrist2.x, 2) + Math.pow(wrist1.y - wrist2.y, 2)
                );
                const minDistance = 0.1;
                const maxDistance = 0.6;
                const normalizedDistance = Math.min(1.0, Math.max(0.0, (handDistance - minDistance) / (maxDistance - minDistance)));
                rawScaleInput = 0.5 + normalizedDistance * 0.5;
                const centerX = (wrist1.x + wrist2.x) / 2;
                const centerY = (wrist1.y + wrist2.y) / 2;
                
                currentHandPosition = new THREE.Vector3(
                    (0.5 - centerX) * SCENE_SENSITIVITY, 
                    (0.5 - centerY) * SCENE_SENSITIVITY, 
                    0 
                );

            } else if (handCount === 1) {
                const handLandmarks = detectedHands[0];
                const thumbTip = handLandmarks[4];
                const pinkyTip = handLandmarks[20];
                
                if (!thumbTip || !pinkyTip) return; 

                const fingerDistance = Math.sqrt(
                    Math.pow(thumbTip.x - pinkyTip.x, 2) + Math.pow(thumbTip.y - pinkyTip.y, 2)
                );
                const minClosure = 0.05; 
                const maxOpen = 0.35;    
                const normalizedDistance = Math.min(1.0, Math.max(0.0, (fingerDistance - minClosure) / (maxOpen - minClosure)));
                rawScaleInput = 0.5 + normalizedDistance * 2.0; 
                const wrist = handLandmarks[0];
                
                currentHandPosition = new THREE.Vector3(
                    (0.5 - wrist.x) * SCENE_SENSITIVITY, 
                    (0.5 - wrist.y) * SCENE_SENSITIVITY, 
                    0 
                );
            } 
            
            if (currentHandPosition) {
                const limit = 3.5;
                currentHandPosition.x = Math.min(limit, Math.max(-limit, currentHandPosition.x));
                currentHandPosition.y = Math.min(limit, Math.max(-limit, currentHandPosition.y));
                positionXHistory.push(currentHandPosition.x);
                positionYHistory.push(currentHandPosition.y);
                if (positionXHistory.length > WINDOW_SIZE) { 
                    positionXHistory.shift(); 
                    positionYHistory.shift(); 
                }
                const smoothX = positionXHistory.reduce((a, b) => a + b, 0) / positionXHistory.length;
                const smoothY = positionYHistory.reduce((a, b) => a + b, 0) / positionYHistory.length;
                targetPosition.set(smoothX, smoothY, 0);
                scaleHistory.push(rawScaleInput);
                if (scaleHistory.length > WINDOW_SIZE) { 
                    scaleHistory.shift(); 
                }
                const smoothScale = scaleHistory.reduce((a, b) => a + b, 0) / scaleHistory.length;
                targetScale = Math.min(3.5, Math.max(0.5, smoothScale)); 

                lastMotionTime = Date.now();

            } else {
                targetScale = 1.0; 
                targetPosition.set(0, 0, 0); 
                scaleHistory = [];
                positionXHistory = [];
                positionYHistory = [];
            }
        }

        async function setupMediaPipe() {
            const videoElement = document.getElementById('webcam-video');

            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults); 

            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error("æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´ APIã€‚");
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: "user"
                    } 
                });
                
                videoElement.srcObject = stream;
                
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        resolve();
                    };
                });
                
                await videoElement.play();

                if (typeof Camera === 'undefined') {
                    console.error('Camera å¯¹è±¡æœªå®šä¹‰');
                    return;
                }

                const cameraMP = new Camera(videoElement, {
                    onFrame: async () => {
                        if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
                            try {
                                await hands.send({ image: videoElement });
                            } catch (e) {}
                        }
                    },
                    width: 640,
                    height: 480
                });

                cameraMP.start();
                console.log("MediaPipe æ‰‹åŠ¿è¯†åˆ«å·²å¯åŠ¨");

            } catch (err) {
                console.error("MediaPipe åˆå§‹åŒ–å¤±è´¥:", err);
            }
        }

        // =================================================================
        //                 çƒŸèŠ±æ•ˆæœå®ç°
        // =================================================================
        
        function createRocketTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createLinearGradient(0, 0, 0, 32);
            gradient.addColorStop(0, 'rgba(255, 200, 100, 0.9)');
            gradient.addColorStop(0.3, 'rgba(255, 150, 50, 0.6)');
            gradient.addColorStop(0.7, 'rgba(255, 100, 0, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 16, 32);
            
            return new THREE.CanvasTexture(canvas);
        }

        function createSparkTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 8;
            canvas.height = 48;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createLinearGradient(0, 0, 0, 48);
            gradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 220, 100, 0.9)');
            gradient.addColorStop(0.5, 'rgba(255, 150, 50, 0.6)');
            gradient.addColorStop(0.8, 'rgba(255, 100, 0, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 8, 48);
            
            return new THREE.CanvasTexture(canvas);
        }

        function getRandomRocketColor() {
            const colors = [
                new THREE.Color(0xffaa33),
                new THREE.Color(0xff6633),
                new THREE.Color(0xff3366),
                new THREE.Color(0x33ff99),
                new THREE.Color(0x3399ff),
                new THREE.Color(0xff33ff),
                new THREE.Color(0xffff33)
            ];
            return colors[Math.floor(Math.random() * colors.length)].clone();
        }

        function createRocket() {
            const range = FIREWORK_CONFIG.randomPositionRange;
            const startX = (Math.random() - 0.5) * range.x;
            const startZ = (Math.random() - 0.5) * range.z;
            
            const startY = 1;
            const targetY = range.yMin + Math.random() * (range.yMax - range.yMin);
            
            const rocketColor = getRandomRocketColor();
            const rocketSpeed = FIREWORK_CONFIG.rocketSpeedMin + 
                               Math.random() * (FIREWORK_CONFIG.rocketSpeedMax - FIREWORK_CONFIG.rocketSpeedMin);
            
            const particleCount = 40;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i*3] = (Math.random() - 0.5) * 0.5;
                positions[i*3+1] = (Math.random() - 0.5) * 1.2;
                positions[i*3+2] = (Math.random() - 0.5) * 0.5;
                
                colors[i*3] = rocketColor.r * (0.8 + 0.2 * Math.random());
                colors[i*3+1] = rocketColor.g * (0.8 + 0.2 * Math.random());
                colors[i*3+2] = rocketColor.b * (0.8 + 0.2 * Math.random());
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.25,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                map: createRocketTexture(),
                depthWrite: false,
                transparent: true,
                sizeAttenuation: true
            });
            
            const rocket = new THREE.Points(geometry, material);
            rocket.position.set(startX, startY, startZ);
            
            const trailCount = 60;
            const trailGeometry = new THREE.BufferGeometry();
            const trailPositions = new Float32Array(trailCount * 3);
            const trailColors = new Float32Array(trailCount * 3);
            
            for (let i = 0; i < trailCount; i++) {
                trailPositions[i*3] = 0;
                trailPositions[i*3+1] = 0;
                trailPositions[i*3+2] = 0;
                
                const fade = 1 - i / trailCount;
                trailColors[i*3] = rocketColor.r * fade * 0.8;
                trailColors[i*3+1] = rocketColor.g * fade * 0.8;
                trailColors[i*3+2] = rocketColor.b * fade * 0.8;
            }
            
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
            
            const trailMaterial = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                map: createSparkTexture(),
                depthWrite: false,
                transparent: true,
                sizeAttenuation: true
            });
            
            const trail = new THREE.Points(trailGeometry, trailMaterial);
            rocket.add(trail);
            
            rocket.userData = {
                type: 'rocket',
                startY: startY,
                targetY: targetY,
                progress: 0,
                speed: rocketSpeed,
                color: rocketColor,
                trail: trail,
                trailPositions: trailPositions,
                trailIndex: 0,
                exploded: false
            };
            
            return rocket;
        }

        function createExplosion(position) {
            const count = FIREWORK_PARAMS.particleCount;
            const particleSize = FIREWORK_PARAMS.particleSize;
            const brightness = FIREWORK_PARAMS.brightness;
            
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const velocities = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const ages = new Float32Array(count);
            
            const goldColors = [
                new THREE.Color(0xffaa33),
                new THREE.Color(0xffdd55),
                new THREE.Color(0xffffee),
                new THREE.Color(0xff8833),
                new THREE.Color(0xffaa55),
                new THREE.Color(0xffbb44)
            ];
            
            for (let i = 0; i < count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const speed = 0.18 + Math.random() * 0.25;
                
                velocities[i*3] = Math.sin(phi) * Math.cos(theta) * speed;
                velocities[i*3+1] = Math.sin(phi) * Math.sin(theta) * speed;
                velocities[i*3+2] = Math.cos(phi) * speed;
                
                positions[i*3] = 0;
                positions[i*3+1] = 0;
                positions[i*3+2] = 0;
                
                ages[i] = Math.random() * FIREWORK_CONFIG.trailLength;
                
                const goldColor = goldColors[Math.floor(Math.random() * goldColors.length)].clone();
                colors[i*3] = goldColor.r * (0.9 + 0.3 * Math.random()) * brightness;
                colors[i*3+1] = goldColor.g * (0.8 + 0.3 * Math.random()) * brightness;
                colors[i*3+2] = goldColor.b * (0.6 + 0.3 * Math.random()) * brightness;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('age', new THREE.BufferAttribute(ages, 1));
            
            geometry.userData.velocities = velocities;
            geometry.userData.initialColors = colors.slice(0);
            
            const material = new THREE.PointsMaterial({
                size: particleSize,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                map: createSparkTexture(),
                depthWrite: false,
                transparent: true,
                sizeAttenuation: true
            });
            
            const explosion = new THREE.Points(geometry, material);
            explosion.position.copy(position);
            
            explosion.userData = {
                velocities: velocities,
                initialColors: colors.slice(0),
                ages: ages,
                lifetime: 5.0,
                elapsed: 0,
                trailLength: FIREWORK_CONFIG.trailLength
            };
            
            return explosion;
        }

        function updateFireworks(delta, currentTime) {
            const deltaSec = delta / 1000;
            
            for (let i = rockets.length - 1; i >= 0; i--) {
                const rocket = rockets[i];
                
                if (!rocket.userData.exploded) {
                    rocket.userData.progress += deltaSec * rocket.userData.speed;
                    
                    if (rocket.userData.progress >= 1) {
                        rocket.userData.exploded = true;
                        
                        const explosion = createExplosion(rocket.position.clone());
                        scene.add(explosion);
                        fireworks.push(explosion);
                        
                        scene.remove(rocket);
                        rockets.splice(i, 1);
                    } else {
                        const newY = rocket.userData.startY + (rocket.userData.targetY - rocket.userData.startY) * rocket.userData.progress;
                        rocket.position.y = newY;
                        
                        const trail = rocket.userData.trail;
                        if (trail) {
                            const positions = trail.geometry.attributes.position.array;
                            const trailIndex = rocket.userData.trailIndex || 0;
                            
                            for (let j = 0; j < positions.length / 3; j++) {
                                const idx = (trailIndex - j + positions.length / 3) % (positions.length / 3);
                                positions[idx*3] = 0;
                                positions[idx*3+1] = -j * 0.2;
                                positions[idx*3+2] = 0;
                            }
                            
                            rocket.userData.trailIndex = (trailIndex + 1) % (positions.length / 3);
                            trail.geometry.attributes.position.needsUpdate = true;
                        }
                    }
                }
            }
            
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const f = fireworks[i];
                f.userData.elapsed += deltaSec;
                
                const positions = f.geometry.attributes.position.array;
                const velocities = f.userData.velocities;
                const colorsAttr = f.geometry.attributes.color.array;
                const ages = f.userData.ages;
                const count = positions.length / 3;
                
                for (let j = 0; j < count; j++) {
                    positions[j*3] += velocities[j*3] * deltaSec * 25;
                    positions[j*3+1] += velocities[j*3+1] * deltaSec * 25;
                    positions[j*3+2] += velocities[j*3+2] * deltaSec * 25;
                    
                    ages[j] += deltaSec * 35;
                    
                    const ageRatio = Math.min(1, ages[j] / f.userData.trailLength);
                    const fadeFactor = Math.max(0, 1 - f.userData.elapsed / f.userData.lifetime);
                    
                    const originalR = f.userData.initialColors[j*3];
                    const originalG = f.userData.initialColors[j*3+1];
                    const originalB = f.userData.initialColors[j*3+2];
                    
                    colorsAttr[j*3] = originalR * fadeFactor * (1 - ageRatio * 0.6);
                    colorsAttr[j*3+1] = originalG * fadeFactor * (1 - ageRatio * 0.6);
                    colorsAttr[j*3+2] = originalB * fadeFactor * (1 - ageRatio * 0.6);
                }
                
                f.geometry.attributes.position.needsUpdate = true;
                f.geometry.attributes.color.needsUpdate = true;
                
                if (f.userData.elapsed >= f.userData.lifetime) {
                    scene.remove(f);
                    fireworks.splice(i, 1);
                }
            }
            
            if (rockets.length + fireworks.length < FIREWORK_CONFIG.maxConcurrentFireworks * 2) {
                if (currentTime >= nextLaunchTime) {
                    const rocket = createRocket();
                    scene.add(rocket);
                    rockets.push(rocket);
                    
                    const randomInterval = FIREWORK_CONFIG.launchIntervalMin + 
                                          Math.random() * (FIREWORK_CONFIG.launchIntervalMax - FIREWORK_CONFIG.launchIntervalMin);
                    nextLaunchTime = currentTime + randomInterval;
                }
            }
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            const delta = lastTime ? time - lastTime : 16;
            const deltaSec = delta / 1000;
            lastTime = time;
            
            particleScale += (targetScale - particleScale) * 0.1;
            particlesPosition.lerp(targetPosition, SMOOTHING_FACTOR);

            const ENTER_THRESHOLD = 2.2; 
            const EXIT_THRESHOLD = 1.8;
            
            if (particleScale > ENTER_THRESHOLD && !insideStar) {
                cameraTargetZ = -0.5; 
                cometTrails1.forEach(trail => trail.visible = false);
                cometTrails2.forEach(trail => trail.visible = false);
                insideStar = true;
                
            } else if (particleScale < EXIT_THRESHOLD && insideStar) {
                cameraTargetZ = 10; 
                cometTrails1.forEach(trail => trail.visible = true);
                cometTrails2.forEach(trail => trail.visible = true);
                insideStar = false;
            }

            camera.position.z += (cameraTargetZ - camera.position.z) * 0.1;
            
            orbitTime += Params.orbitSpeed;
            const orbitRadius = Params.orbitRadius * particleScale; 
            
            const starPos1 = new THREE.Vector3(
                orbitRadius * Math.cos(orbitTime),
                orbitRadius * Math.sin(orbitTime),
                0
            );
            const rotationMatrix = new THREE.Matrix4().makeRotationX(ORBIT_TILT_ANGLE);
            
            const currentStar1Pos = starPos1.clone().applyMatrix4(rotationMatrix).add(particlesPosition);
            
            const starPos2 = new THREE.Vector3(
                orbitRadius * Math.cos(orbitTime + Math.PI), 
                orbitRadius * Math.sin(orbitTime + Math.PI),
                0
            ).applyMatrix4(rotationMatrix).add(particlesPosition);
            
            if (star1 && star2) {
                star1.position.copy(currentStar1Pos);
                star2.position.copy(starPos2);
                
                star1.scale.set(particleScale, particleScale, particleScale);
                star2.scale.set(particleScale, particleScale, particleScale);
                star1.rotation.z += 0.005; 
                star2.rotation.z -= 0.005; 
            }

            // æ›´æ–°å½—æ˜Ÿå°¾å·´ - æŠ›ç‰©çº¿æ•ˆæœ
            updateCometTrails(deltaSec);
            
            if (backgroundParticles) {
                backgroundParticles.rotation.y -= 0.0005;
            }
            
            updateFireworks(delta, time);
            
            if (musicPlaying) {
                manageMusicVolume();
            }

            if (composer) {
                composer.render();
            } else if (renderer) {
                renderer.render(scene, camera);
            }
        }
        
        // =================================================================
        //                     åˆå§‹åŒ–å’Œäº‹ä»¶ç»‘å®š
        // =================================================================

        function init() {
            const container = document.getElementById('container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = cameraTargetZ;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 1);
            container.appendChild(renderer.domElement);

            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 
                                                        Params.bloomStrength, Params.bloomRadius, Params.bloomThreshold);

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // åˆ›å»ºåŒå­æ˜Ÿç²’å­ç³»ç»Ÿ
            star1 = updateParticleSystem(star1, 'Sphere', Params.starColor1, Params.starDensity, Params.targetSpread, Params.particleSize, true);
            star2 = updateParticleSystem(star2, 'Sphere', Params.starColor2, Params.starDensity, Params.targetSpread, Params.particleSize, true);
            
            // åˆ›å»ºæŠ›ç‰©çº¿æ•ˆæœçš„å½—æ˜Ÿå°¾å·´
            createAllCometTrails();
            
            createBackgroundParticles();
            
            preloadImages();
            
            nextLaunchTime = performance.now() + 2000;
            
            const gui = new dat.GUI();
            gui.addColor(Params, 'starColor1').onChange(() => updateParticleSystem(star1, 'Sphere', Params.starColor1, Params.starDensity, Params.targetSpread, Params.particleSize));
            gui.addColor(Params, 'starColor2').onChange(() => updateParticleSystem(star2, 'Sphere', Params.starColor2, Params.starDensity, Params.targetSpread, Params.particleSize));
            gui.add(Params, 'particleSize', 0.01, 0.1).name('Star Size').onChange(() => {
                if(star1) star1.material.size = Params.particleSize;
                if(star2) star2.material.size = Params.particleSize;
            });
            gui.add(Params, 'targetSpread', 1, 5).name('Star Spread').onChange(() => {
                star1 = updateParticleSystem(star1, 'Sphere', Params.starColor1, Params.starDensity, Params.targetSpread, Params.particleSize);
                star2 = updateParticleSystem(star2, 'Sphere', Params.starColor2, Params.starDensity, Params.targetSpread, Params.particleSize);
            });
            gui.add(Params, 'orbitRadius', 1, 5).name('Orbit Radius');
            gui.add(Params, 'orbitSpeed', 0.001, 0.1).name('Orbit Speed');
            
            const bloomFolder = gui.addFolder('Bloom Effect');
            bloomFolder.add(Params, 'bloomStrength', 0, 5).name('Strength').onChange(value => bloomPass.strength = value);
            bloomFolder.add(Params, 'bloomRadius', 0, 2).name('Radius').onChange(value => bloomPass.radius = value);
            bloomFolder.add(Params, 'bloomThreshold', 0, 1).name('Threshold').onChange(value => bloomPass.threshold = value);
            bloomFolder.open();
            
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
            
            setupMusicControls();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            init();
            setTimeout(() => {
                if (typeof setupMediaPipe === 'function') {
                    setupMediaPipe().catch(err => {
                        console.error("æ‰‹åŠ¿è¯†åˆ«å¯åŠ¨å¤±è´¥", err);
                    });
                }
            }, 1000);
            createWindowsLoop();
            animate();
        });
        
    </script>
</body>
</html>